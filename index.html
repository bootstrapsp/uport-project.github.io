 <!DOCTYPE html><html><head><title>UPort Documentation</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><link rel="stylesheet" href="css/style.css"></head><body><header class="header"><div class="header-wrap"><div class="header-left"><a class="logo-link"><div class="logo-group"><img class="logo-img" src="#"><span>| Developers</span></div></a></div><div class="header-right"><nav class="nav"><ul class="nav-list"><li class="nav-item"><a class="nav-link" href="#guides"><span>Guides</span></a></li><li class="nav-item"><a class="nav-link" href="#apidocs"><span>API Docs</span></a></li><li class="nav-item"><a class="nav-link" href="#tools"><span>Tools</span></a></li><li class="nav-item"><a class="nav-link" href="#myapps"><span>My Apps</span></a></li><li class="nav-item"><a class="nav-link" href="#gitter"><span>Gitter</span></a></li><li class="nav-item"><a class="nav-link" href="https://github.com/uport-project" target="_blank"><span>Github</span></a></li></ul></nav><div class="user-area"><a class="sign-in-link" href="#"><span>Sign In</span></a><div class="user"><img class="user-pic" src="#"><div class="user-menu"><ul><li class="user"><b class="user-name">Jeff Scott Ward</b><span class="user-addr">0x9239812437981247</span></li><li class="log-out"><a href="#">Log Out</a></li></ul></div></div></div></div></div></header><!-- default to .main.______ page--><main class="main apidocs"><div class="portal"><div class="banner"><div class="banner-text"><h1>uPort Documentation</h1><p class="text-block">uPort is an open source software project to establish a global, unified, sovereign identity system for people, businesses, organizations, devices, and bots.</p></div><div class="banner-steps"><ul><li class="alpha"><div class="number"><span class="number-text">1</span></div><img class="step-img" src="#"><div class="step-desc">Download the Mobile Wallet</div></li><li class="beta"><div class="number"><span class="number-text">2</span></div><img class="step-img" src="#"><div class="step-desc">Register Your App</div></li><li class="omega"><div class="number"><span class="number-text">3</span></div><img class="step-img" src="#"><div class="step-desc">Install the Libraries / SDK's</div></li></ul></div></div><div class="content-shortcuts"><ul><li class="guides"><div class="shortcut-wrap"><img src="#"><label>Guides</label></div><div class="list-wrap"><ul><li><a href="#"><span>Getting Started</span></a></li><li><a href="#"><span>Requesting Credentials</span></a></li><li><a href="#"><span>Attesting Credentials</span></a></li><li><a href="#"><span>Signing Transactions</span></a></li></ul></div></li><li class="api-docs"><div class="shortcut-wrap"><img src="#"><label>API Docs</label></div><div class="list-wrap"><ul><li><a href="#"><span>uport-connect</span></a></li><li><a href="#"><span>uport-js</span></a></li><li><a href="#"><span>uport-lite</span></a></li><li><a href="#"><span>uport-registry</span></a></li></ul></div></li><li class="tools"><div class="shortcut-wrap"><img src="#"><label>Tools</label></div><div class="list-wrap"><ul><li><a href="http://truffleframework.com"><span>Truffle</span></a></li><li><a href="http://metamask.io"><span>MetaMask</span></a></li><li><a href="https://remix.ethereum.org/#version=soljson-v0.4.13+commit.fb4cb1a.js"><span>Remix</span></a></li><li><a href="https://github.com/ethereum/mist/releases"><span>Mist</span></a></li></ul></div></li></ul></div></div><div class="guides"><div class="pagewrap"><div class="sidebar"><section><h2>Getting Started</h2><ul><li><a href="#"><span>Download the Mobile App</span></a></li><li><a href="#"><span>Create your Identity</span></a></li><li><a href="#"><span>Register your App</span></a></li><li><a href="#"><span>Install the Library/SDK</span></a></li><li><a href="#"><span>Add your Keys</span></a></li></ul></section><section><h2>Requesting Credentials</h2><ul><li><a href="#"><span>Calling the Method</span></a></li><li><a href="#"><span>Requesting specific crednetials</span></a></li><li><a href="#"><span>Enabling Push Notifications</span></a></li><li><a href="#"><span>Logging in via Desktop (web)</span></a></li><li><a href="#"><span>Custom QR Styling</span></a></li><li><a href="#"><span>Logging in via Mobile (web)</span></a></li><li><a href="#"><span>Logging in via Mobile (sdk)</span></a></li></ul></section><section><h2>Attesting Credentials</h2><ul><li><a href="#"><span>Calling the Method</span></a></li><li><a href="#"><span>Attesting a credential</span></a></li><li><a href="#"><span>Setting an expiration date</span></a></li><li><a href="#"><span>Attesting multiple credentials</span></a></li></ul></section><section><h2>Signing Transactions</h2><ul><li><a href="#"><span>Supply the contract ABI</span></a></li><li><a href="#"><span>Create the contract object</span></a></li><li><a href="#"><span>Call a method on the contract</span></a></li><li><a href="#"><span>Wait for mining to complete</span></a></li></ul></section></div><div class="content">     <h1>Getting Started</h1>
<p>The interactive tutorials on this site require the use of the uPort mobile app.</p>
<p>If you don’t have the mobile app installed, <a href="http://uport.me/signup">sign up for our alpha</a>.</p>
<p>Once you have downloaded the mobile app, go ahead and create an app over at the <a href="appmanager.uport.me">uPort App Manager</a>.</p>
<hr><h1>User Guide - uport-connect</h1>
<h2>Install uport-connect</h2>
<p>The first thing naturally is to go an download the library for use in your project.</p>
<p><code>npm install --save uport-connect</code></p>
<p>alternatively you can (and should) use yarn</p>
<p><code>yarn add uport-connect</code></p>
<p>and then import the library like so...</p>
<pre><code class="language-js">import { Connect, SimpleSigner } from 'uport-connect'
</code></pre>
<h2>Setting the uPort object</h2>
<p>Before making use of these features for yourself, we need to instantiate the uPort object with an identity.</p>
<p>Now grab the <code>Connect</code> function and feed in the App's name, id, and signing key.</p>
<p>The clientID is the public address of your app and the signer (wrapped with the SimpleSigner function) is the signing key of your app that you will help create JWT tokens. These bits of information are given to you after creating an application with the <a href="appmanager.uport.me">uPort App Manager</a>.</p>
<p>We should also export the <code>web3</code> object for signing transactions later.</p>
<blockquote>
<p>Make sure to replace <strong>NAME_OF_DAPP</strong> with the App's Name, <strong>CLIENT_ID</strong> with the public address of your App, and the <strong>SIGNING KEY</strong> with the private key of the App supplied by the App Manager.</p>
</blockquote>
<pre><code class="language-js">const uport = new Connect('NAME_OF_DAPP', {
  clientId: 'CLIENT_ID',
  signer: SimpleSigner('SIGNING KEY')
})

const web3 = uport.getWeb3()
export { web3, uport }
</code></pre>
<h2>Connect with uPort</h2>
<p>One of the most basic things you should do is allow your user to connect their uPort to your app.</p>
<p><strong>By default</strong> the uport-connect library will fire a QR image inside of an injected global modal to help you get up an running quickly.</p>
<p><strong>This can be disabled</strong> by intercepting the URI so you may use another library to customize the look and feel of the QR image.</p>
<p>You can request specific credentials by submitting an array of values in an array of the <code>requested</code> key of a passed object.</p>
<p>When a transaction is going to be signed, if the <code>notifications</code> flag is set to <code>true</code> <strong>it will allow any future transaction signing to fire a prompt in the uPort mobile app.</strong></p>
<p><code>uport.requestCredentials</code> documentation can be found <a href="#requestCredentials">here</a>.</p>
<blockquote>
<p>Once the user has scanned the displayed QR image, and has submitted their credentials, the promise should resolve with a Schema.org person JSON data payload. You can then handle this data however you desire in the then function.</p>
</blockquote>
<pre><code class="language-js">// Basic usage with modal injection
uport.requestCredentials()
     .then((credentials) =&gt; {
       // Do something after they have scanned in
})
</code></pre>
<blockquote>
<p>Request specific credentials, enable notifications, and create a custom QR Code</p>
</blockquote>
<pre><code class="language-js">uport.requestCredentials({
  requested: ['name', 'phone', 'country'],
  notifcations: true,
  (uri) =&gt; {
    // We have had success with the KJUA Library.
    // https://larsjung.de/kjua/
    const qr = kjua({
      text: uri,
      fill: '#000000',
      size: 400,
      back: 'rgba(255,255,255,1)'
    })

    // Create wrapping link for mobile touch
    let aTag = document.createElement('a')
    aTag.href = uri

    // Nest QR in &lt;a&gt; and inject
    aTag.appendChild(qr)
    document.querySelector('#kqr').appendChild(aTag)
  }
  }).then((credentials) =&gt; {
    // Do something after they have scanned
})
</code></pre>
<h2>Try Connecting Your uPort</h2>
<p>Click the button below and scan the QR code with your uPort App.
This is how you will 'log in' into Web 3.0 applications</p>
<blockquote>
<p>The JSON Schema.org &quot;Person&quot; format you will see</p>
</blockquote>
<pre><code class="language-js">{
  &quot;@context&quot;:&quot;http://schema.org&quot;,
  &quot;@type&quot;:&quot;Person&quot;,
  &quot;name&quot;:&quot;Agent Smith&quot;,
  &quot;address&quot;:&quot;23fga3r2hh87ddhq98dhas8dh101j9f449w0&quot;,
  &quot;network&quot;:&quot;ropsten&quot;,
  &quot;publicKey&quot;:&quot;0x04016751595cf2f1429367d6c83a826526g613b4f7574af55ded0364f0fb34600bceba9211e5864ae616d7e83b5e3c79f1c913b40c8d38c64952fef383fd3ad637&quot;,
  &quot;image&quot;:{
    &quot;@type&quot;:&quot;ImageObject&quot;,
    &quot;name&quot;:&quot;avatar&quot;,
    &quot;contentUrl&quot;:&quot;/ipfs/QmeXP3C3S95zV9Wj9e2VTq9Z3CCCNoqksJrM5VQYJx2yM9&quot;
  }
}
</code></pre>
<h2>Signing Transactions</h2>
<p>uPort comes pre-baked with a web3 instance that calls to <a href="https://github.com/ethereumjs/testrpc">Infura</a> to make your life easy. All you need to do is grab our web3 object and instantiate a smart contract javascript object with a <strong>provided ABI</strong>.</p>
<p>An ABI (Application BINARY Interface) can be generated by compiling your smart contract with the <a href="https://ethereum.github.io/browser-solidity/">Remix</a> Web IDE. Its on the &quot;Contracts&quot; tab down where it says <code>interface</code>. You can deploy this contract to the chain with the <strong>Web3</strong> deploy code just below that in your local Ethereum node console or with our build &amp; deploy tool called <a href="http://truffleframework.com/">Truffle</a>.</p>
<pre><code class="language-js">function MyContractSetup () {
  let MyContractABI = web3.eth.contract(PROVIDED_CONTRACT_ABI)
  let MyContractObj = MyContractABI.at(DEPLOYED_CONTRACT_ADDRESS_LOCATION)
  return MyContractObj
}
const MyContract = MyContractSetup()
</code></pre>
<p>In a typical application, upon load, there is data usually being requested by a server to get the current state of the user's data. We must do the same here, but rather than reading a SQL database, we are instead reading the blockchain. At ConsenSys we use our Web 3.0 infrastructure stack called <a href="https://github.com/uport-project/demo/blob/master/infura.io">Infura</a> to make the amount of possible calls scalable. You could otherwise have an Ethereum node local on your machine with a downloaded copy of the blockchain you could query. Calls can be simulated without having a copy of the blockchain though using a local <a href="https://github.com/ethereumjs/testrpc">TestRPC</a> node, but thats out of scope for this explainer.</p>
<pre><code class="language-js">// Basic call to get some return data, no transaction signing
MyContract.someMethod.call(METHOD_INPUT_DATA, (error, response) =&gt; {
  if (error) { throw error }
  console.log(response)
})
</code></pre>
<p>When a transaction is signed and submitted to a smart contract, the Ethereum network takes time to mine (confirm) the transaction (typically 15 seconds). During this time we will need to poll the Web3 node (aka provider and in our case, its Infura), to see if its been mined. We will keep checking it with a function called <code>waitForMined</code> and have a pending callback and a success callback to manage state.</p>
<pre><code class="language-js">// Transaction signing (that will fire a QR to scan or card in the mobile app)
MyContract.someMethod(METHOD_INPUT_DATA, (error, txHash) =&gt; {
  if (error) { throw error }
    waitForMined(txHash, { blockNumber: null },
    function pendingCB () {
      // Signal to the user you're still waiting
      // for a block confirmation
    },
    function successCB (data) {
      // Great Success!
      // Likely you'll call some eventPublisherMethod(txHash, data)
    }
  )
})

// Callback handler for whether it was mined or not
const waitForMined = (txHash, response, pendingCB, successCB) =&gt; {
  if (response.blockNumber) {
    successCB()
  } else {
    pendingCB()
      pollingLoop(txHash, response, pendingCB, successCB)
  }
}

// Recursive polling to do continuous checks for when the transaction was mined
const pollingLoop = (txHash, response, pendingCB, successCB) =&gt; {
  setTimeout(function () {
    web3.eth.getTransaction(txHash, (error, response) =&gt; {
      if (error) { throw error }
        if (response === null) {
          response = { blockNumber: null }
        } // Some ETH nodes do not return pending tx
        waitForMined(txHash, response, pendingCB, successCB)
    })
  }, 1000) // check again in one sec.
}
</code></pre>
<h2>Attesting Credentials</h2>
<p>One of the core needs of Web 3.0 is to build trust in a self-soverign world. We establish facts which are not mathmatically derived by social consensus. To create social consensus, actors must attest to things being true. We can do this with uPort using the <code>attestCredentials</code> function.</p>
<p><strong>NOTE:</strong> Currently only one credential can be pushed at a time. We are working to fix this soon.</p>
<pre><code class="language-js">uport.attestCredentials({
  sub: 'THE_RECEIVING_UPORT_ID',
  claim: { CUSTOM_PROPERTY: PROPERTY_VALUE },
  exp: new Date().getTime() + 30 * 24 * 60 * 60 * 1000,  // Optional expiration
})
</code></pre>
<h2>Congratulations</h2>
<p>You have now have good grasp about how to use uPort and how to manage the user experience of Web 3.0 applications. Welcome!</p>
</div></div></div><div class="apidocs"><div class="pagewrap"><div class="sidebar"><section><h2>uport-connect</h2><ul><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li></ul></section><section><h2>uport-lite</h2><ul><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li></ul></section><section><h2>uport-js</h2><ul><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li></ul></section><section><h2>uport-registry</h2><ul><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li><li><a href="#"><span>Blah blah blah blah</span></a></li></ul></section></div><div class="content"><h2>Classes</h2>
<dl>
<dt><a href="#Connect">Connect</a> ⇐ <a href="#ConnectCore">ConnectCore</a></dt>
<dd><p>Primary object for frontend interactions with uPort. Bundles all neccesary functionality.</p>
</dd>
<dt><a href="#ConnectCore">ConnectCore</a></dt>
<dd><p>Primary object for frontend interactions with uPort. ConnectCore excludes
 some functionality found in Connect for a more customizable and lightweight integration.
 It does not provide any web3 functionality althought you can still use getProvider
 to get a provider to use with web3 or other libraries. It removes all default
 QR injection functionality. Your can choose how you want to handle the UX and/or
 QR generation and use any QR library you choose. For example, if used in a
 mobile native app QR generation is not even necessary.</p>
</dd>
<dt><a href="#UportSubprovider">UportSubprovider</a></dt>
<dd><p>A web3 style provider which can easily be wrapped with uPort functionality.
 Builds on a base provider. Used in Connect to wrap a provider with uPort specific
 functionality.</p>
</dd>
</dl>
<p><a name="Connect"></a></p>
<h2>Connect ⇐ <a href="#ConnectCore">ConnectCore</a></h2>
<p>Primary object for frontend interactions with uPort. Bundles all neccesary functionality.</p>
<p><strong>Kind</strong>: global class<br>
<strong>Extends</strong>: <a href="#ConnectCore">ConnectCore</a></p>
<ul>
<li><a href="#Connect">Connect</a> ⇐ <a href="#ConnectCore">ConnectCore</a>
<ul>
<li><a href="#new_Connect_new">new Connect(appName, [opts])</a></li>
<li><a href="#Connect+getWeb3">.getWeb3()</a> ⇒ web3</li>
<li><a href="#ConnectCore+getProvider">.getProvider()</a> ⇒ <a href="#UportSubprovider">UportSubprovider</a></li>
<li><a href="#ConnectCore+requestCredentials">.requestCredentials([request], [uriHandler])</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+requestAddress">.requestAddress([uriHandler])</a> ⇒ Promise.&lt;String, Error&gt;</li>
<li><a href="#ConnectCore+attestCredentials">.attestCredentials(credential, [uriHandler])</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+request">.request(request)</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+contract">.contract(abi)</a> ⇒ Object</li>
<li><a href="#ConnectCore+sendTransaction">.sendTransaction(txobj)</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+addAppParameters">.addAppParameters(txobj, callbackUrl)</a> ⇒ Promise.&lt;Object, Error&gt;</li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_Connect_new"></a></p>
<h3>new Connect(appName, [opts])</h3>
<p>Instantiates a new uPort connect object.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>appName</td><td>String</td><td></td><td><p>the name of your app</p>
</td>
    </tr><tr>
    <td>[opts]</td><td>Object</td><td></td><td><p>optional parameters</p>
</td>
    </tr><tr>
    <td>opts.credentials</td><td>Object</td><td></td><td><p>pre-configured Credentials object from <a href="http://github.com/uport-project/uport-js">http://github.com/uport-project/uport-js</a> object. Configure this if you need to create signed requests</p>
</td>
    </tr><tr>
    <td>opts.signer</td><td>function</td><td></td><td><p>signing function which will be used to sign JWT&#39;s in the credentials object</p>
</td>
    </tr><tr>
    <td>opts.clientId</td><td>String</td><td></td><td><p>uport identifier for your application this will be used in the default credentials object</p>
</td>
    </tr><tr>
    <td>[opts.network]</td><td>Object</td><td>&#x27;kovan&#x27;</td><td><p>network config object or string name, ie. { id: &#39;0x1&#39;, registry: &#39;0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6&#39;, rpcUrl: &#39;<a href="https://mainnet.infura.io">https://mainnet.infura.io</a>&#39; } or &#39;kovan&#39;, &#39;mainnet&#39;, &#39;ropsten&#39;.</p>
</td>
    </tr><tr>
    <td>opts.rpcUrl</td><td>String</td><td></td><td><p>JSON rpc url (defaults to <a href="https://ropsten.infura.io">https://ropsten.infura.io</a>)</p>
</td>
    </tr><tr>
    <td>opts.infuraApiKey</td><td>String</td><td></td><td><p>Infura API Key (register here <a href="http://infura.io/register.html">http://infura.io/register.html</a>)</p>
</td>
    </tr><tr>
    <td>opts.topicFactory</td><td>function</td><td></td><td><p>function which generates topics and deals with requests and response</p>
</td>
    </tr><tr>
    <td>opts.uriHandler</td><td>function</td><td></td><td><p>default function to consume generated URIs for requests, can be used to display QR codes or other custom UX</p>
</td>
    </tr><tr>
    <td>opts.mobileUriHandler</td><td>function</td><td></td><td><p>default function to consume generated URIs for requests on mobile</p>
</td>
    </tr><tr>
    <td>opts.closeUriHandler</td><td>function</td><td></td><td><p>default function called after a request receives a response, can be to close QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">import { Connect } from 'uport-connect'
const uPort = new Connect('Mydapp')
</code></pre>
<hr>
<p><a name="Connect+getWeb3"></a></p>
<h3>connect.getWeb3() ⇒ web3</h3>
<p>Instantiates and returns a web3 object wrapped with uPort functionality. For
more details see uportSubprovider and getProvider in connectCore.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: web3 - A uPort web3 object</p>
<hr>
<p><a name="ConnectCore+getProvider"></a></p>
<h3>connect.getProvider() ⇒ <a href="#UportSubprovider">UportSubprovider</a></h3>
<p>Instantiates and returns a web3 styple provider wrapped with uPort functionality.
For more details see uportSubprovider. uPort overrides eth_coinbase and eth_accounts
to start a get address flow or to return an already received address. It also
overrides eth_sendTransaction to start the send transaction flow to pass the
transaction to the uPort app.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: <a href="#UportSubprovider">UportSubprovider</a> - A web3 style provider wrapped with uPort functionality</p>
<hr>
<p><a name="ConnectCore+requestCredentials"></a></p>
<h3>connect.requestCredentials([request], [uriHandler]) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Creates a request given a request object, will also always return the user's
uPort address. Calls given uriHandler with the uri. Returns a promise to
wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - a promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[request]</td><td>Object</td><td>{}</td><td><p>request object</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const req = {requested: ['name', 'country']}
 connect.requestCredentials(req).then(credentials =&gt; {
     const address = credentials.address
     const name = credentials.name
     ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+requestAddress"></a></p>
<h3>connect.requestAddress([uriHandler]) ⇒ Promise.&lt;String, Error&gt;</h3>
<p>Creates a request for only the address of the uPort identity. Calls given
uriHandler with the uri. Returns a promise to wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Promise.&lt;String, Error&gt; - a promise which resolves with an address or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+attestCredentials"></a></p>
<h3>connect.attestCredentials(credential, [uriHandler]) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Consumes a credential object and generates a signed JWT. Creates a request
URI with the JWT. Calls given uriHandler with the URI. Returns a promise to wait
for the response. Throws error if no signer and/or app identifier is set.
Will not always receive a response, response is only a status.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - a promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>credential</td><td>Object</td><td></td><td><p>credential object</p>
</td>
    </tr><tr>
    <td>credential.sub</td><td>String</td><td></td><td><p>subject of this credential</p>
</td>
    </tr><tr>
    <td>credential.claim</td><td>Object</td><td></td><td><p>statement(s) which this credential claims, contructed as {key: &#39;value&#39;, ...}</p>
</td>
    </tr><tr>
    <td>credential.exp</td><td>String</td><td></td><td><p>expiry time of this credential</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const cred = {
   sub: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'
   claim: {'email': 'hello@uport.me'}
   exp: '1300819380'
 }
 connect.attestCredentials(cred).then(res =&gt; {
   // response okay, received in uPort app
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+request"></a></p>
<h3>connect.request(request) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Create a request and returns a promise which resolves the response. This
function is primarly is used by more specified functions in this class, which
allow you to easily create the URIs and messaging server topics you need here.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>request</td><td>Object</td><td></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>request.uri</td><td>String</td><td></td><td><p>uPort URI</p>
</td>
    </tr><tr>
    <td>request.topic</td><td>String</td><td></td><td><p>messaging server topic object</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td>String</td><td>this.uriHandler</td><td><p>function to consume URI, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+contract"></a></p>
<h3>connect.contract(abi) ⇒ Object</h3>
<p>Builds and returns a contract object which can be used to interact with
a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)
you can call the contract functions with this object. It will create a request,
call the uirHandler with the URI, and return a promise which resolves with
a transtaction ID.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Object - contract object</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>abi</td><td>Object</td><td></td><td><p>contract ABI</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+sendTransaction"></a></p>
<h3>connect.sendTransaction(txobj) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Given a transaction object, similarly defined as the web3 transaction object,
it creates a URI which is passes to the uirHandler. It will create request
and returns a promise which resolves with the transaction id.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td>Object</td><td></td><td><p>transaction object, can also be wrapped using addAppParameters</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const txobject = {
   to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',
   value: '0.1',
   function: setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'),
   appName: 'MyDapp'
 }
 connect.sendTransaction(txobject).then(txID =&gt; {
   ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+addAppParameters"></a></p>
<h3>connect.addAppParameters(txobj, callbackUrl) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Adds application specific data to a transaction object. Then uses this data
when requests are created.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect">Connect</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td>Object</td><td><p>transaction object</p>
</td>
    </tr><tr>
    <td>callbackUrl</td><td>String</td><td><p>application callback url</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore"></a></p>
<h2>ConnectCore</h2>
<p>Primary object for frontend interactions with uPort. ConnectCore excludes
some functionality found in Connect for a more customizable and lightweight integration.
It does not provide any web3 functionality althought you can still use getProvider
to get a provider to use with web3 or other libraries. It removes all default
QR injection functionality. Your can choose how you want to handle the UX and/or
QR generation and use any QR library you choose. For example, if used in a
mobile native app QR generation is not even necessary.</p>
<p><strong>Kind</strong>: global class</p>
<ul>
<li><a href="#ConnectCore">ConnectCore</a>
<ul>
<li><a href="#new_ConnectCore_new">new ConnectCore(appName, [opts])</a></li>
<li><a href="#ConnectCore+getProvider">.getProvider()</a> ⇒ <a href="#UportSubprovider">UportSubprovider</a></li>
<li><a href="#ConnectCore+requestCredentials">.requestCredentials([request], [uriHandler])</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+requestAddress">.requestAddress([uriHandler])</a> ⇒ Promise.&lt;String, Error&gt;</li>
<li><a href="#ConnectCore+attestCredentials">.attestCredentials(credential, [uriHandler])</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+request">.request(request)</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+contract">.contract(abi)</a> ⇒ Object</li>
<li><a href="#ConnectCore+sendTransaction">.sendTransaction(txobj)</a> ⇒ Promise.&lt;Object, Error&gt;</li>
<li><a href="#ConnectCore+addAppParameters">.addAppParameters(txobj, callbackUrl)</a> ⇒ Promise.&lt;Object, Error&gt;</li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_ConnectCore_new"></a></p>
<h3>new ConnectCore(appName, [opts])</h3>
<p>Instantiates a new uPort connectCore object.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>appName</td><td>String</td><td></td><td><p>the name of your app</p>
</td>
    </tr><tr>
    <td>[opts]</td><td>Object</td><td></td><td><p>optional parameters</p>
</td>
    </tr><tr>
    <td>opts.credentials</td><td>Object</td><td></td><td><p>pre-configured Credentials object from <a href="http://github.com/uport-project/uport-js">http://github.com/uport-project/uport-js</a> object. Configure this if you need to create signed requests</p>
</td>
    </tr><tr>
    <td>opts.signer</td><td>function</td><td></td><td><p>signing function which will be used to sign JWT&#39;s in the credentials object</p>
</td>
    </tr><tr>
    <td>opts.clientId</td><td>String</td><td></td><td><p>uport identifier for your application this will be used in the default credentials object</p>
</td>
    </tr><tr>
    <td>[opts.network]</td><td>Object</td><td>&#x27;kovan&#x27;</td><td><p>network config object or string name, ie. { id: &#39;0x1&#39;, registry: &#39;0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6&#39;, rpcUrl: &#39;<a href="https://mainnet.infura.io">https://mainnet.infura.io</a>&#39; } or &#39;kovan&#39;, &#39;mainnet&#39;, &#39;ropsten&#39;.</p>
</td>
    </tr><tr>
    <td>opts.infuraApiKey</td><td>String</td><td></td><td><p>Infura API Key (register here <a href="http://infura.io/register.html">http://infura.io/register.html</a>)</p>
</td>
    </tr><tr>
    <td>opts.topicFactory</td><td>function</td><td></td><td><p>function which generates topics and deals with requests and response</p>
</td>
    </tr><tr>
    <td>opts.uriHandler</td><td>function</td><td></td><td><p>default function to consume generated URIs for requests, can be used to display QR codes or other custom UX</p>
</td>
    </tr><tr>
    <td>opts.mobileUriHandler</td><td>function</td><td></td><td><p>default function to consume generated URIs for requests on mobile</p>
</td>
    </tr><tr>
    <td>opts.closeUriHandler</td><td>function</td><td></td><td><p>default function called after a request receives a response, can be to close QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">import { ConnectCore } from 'uport-connect'
const uPort = new ConnectCore('Mydapp')
</code></pre>
<hr>
<p><a name="ConnectCore+getProvider"></a></p>
<h3>connectCore.getProvider() ⇒ <a href="#UportSubprovider">UportSubprovider</a></h3>
<p>Instantiates and returns a web3 styple provider wrapped with uPort functionality.
For more details see uportSubprovider. uPort overrides eth_coinbase and eth_accounts
to start a get address flow or to return an already received address. It also
overrides eth_sendTransaction to start the send transaction flow to pass the
transaction to the uPort app.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: <a href="#UportSubprovider">UportSubprovider</a> - A web3 style provider wrapped with uPort functionality</p>
<hr>
<p><a name="ConnectCore+requestCredentials"></a></p>
<h3>connectCore.requestCredentials([request], [uriHandler]) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Creates a request given a request object, will also always return the user's
uPort address. Calls given uriHandler with the uri. Returns a promise to
wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - a promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[request]</td><td>Object</td><td>{}</td><td><p>request object</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const req = {requested: ['name', 'country']}
 connect.requestCredentials(req).then(credentials =&gt; {
     const address = credentials.address
     const name = credentials.name
     ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+requestAddress"></a></p>
<h3>connectCore.requestAddress([uriHandler]) ⇒ Promise.&lt;String, Error&gt;</h3>
<p>Creates a request for only the address of the uPort identity. Calls given
uriHandler with the uri. Returns a promise to wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Promise.&lt;String, Error&gt; - a promise which resolves with an address or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+attestCredentials"></a></p>
<h3>connectCore.attestCredentials(credential, [uriHandler]) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Consumes a credential object and generates a signed JWT. Creates a request
URI with the JWT. Calls given uriHandler with the URI. Returns a promise to wait
for the response. Throws error if no signer and/or app identifier is set.
Will not always receive a response, response is only a status.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - a promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>credential</td><td>Object</td><td></td><td><p>credential object</p>
</td>
    </tr><tr>
    <td>credential.sub</td><td>String</td><td></td><td><p>subject of this credential</p>
</td>
    </tr><tr>
    <td>credential.claim</td><td>Object</td><td></td><td><p>statement(s) which this credential claims, contructed as {key: &#39;value&#39;, ...}</p>
</td>
    </tr><tr>
    <td>credential.exp</td><td>String</td><td></td><td><p>expiry time of this credential</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const cred = {
   sub: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'
   claim: {'email': 'hello@uport.me'}
   exp: '1300819380'
 }
 connect.attestCredentials(cred).then(res =&gt; {
   // response okay, received in uPort app
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+request"></a></p>
<h3>connectCore.request(request) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Create a request and returns a promise which resolves the response. This
function is primarly is used by more specified functions in this class, which
allow you to easily create the URIs and messaging server topics you need here.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>request</td><td>Object</td><td></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>request.uri</td><td>String</td><td></td><td><p>uPort URI</p>
</td>
    </tr><tr>
    <td>request.topic</td><td>String</td><td></td><td><p>messaging server topic object</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td>String</td><td>this.uriHandler</td><td><p>function to consume URI, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+contract"></a></p>
<h3>connectCore.contract(abi) ⇒ Object</h3>
<p>Builds and returns a contract object which can be used to interact with
a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)
you can call the contract functions with this object. It will create a request,
call the uirHandler with the URI, and return a promise which resolves with
a transtaction ID.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Object - contract object</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>abi</td><td>Object</td><td></td><td><p>contract ABI</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+sendTransaction"></a></p>
<h3>connectCore.sendTransaction(txobj) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Given a transaction object, similarly defined as the web3 transaction object,
it creates a URI which is passes to the uirHandler. It will create request
and returns a promise which resolves with the transaction id.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td>Object</td><td></td><td><p>transaction object, can also be wrapped using addAppParameters</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td>function</td><td>this.uriHandler</td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const txobject = {
   to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',
   value: '0.1',
   function: setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'),
   appName: 'MyDapp'
 }
 connect.sendTransaction(txobject).then(txID =&gt; {
   ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+addAppParameters"></a></p>
<h3>connectCore.addAppParameters(txobj, callbackUrl) ⇒ Promise.&lt;Object, Error&gt;</h3>
<p>Adds application specific data to a transaction object. Then uses this data
when requests are created.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore">ConnectCore</a><br>
<strong>Returns</strong>: Promise.&lt;Object, Error&gt; - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td>Object</td><td><p>transaction object</p>
</td>
    </tr><tr>
    <td>callbackUrl</td><td>String</td><td><p>application callback url</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="UportSubprovider"></a></p>
<h2>UportSubprovider</h2>
<p>A web3 style provider which can easily be wrapped with uPort functionality.
Builds on a base provider. Used in Connect to wrap a provider with uPort specific
functionality.</p>
<p><strong>Kind</strong>: global class</p>
<ul>
<li><a href="#UportSubprovider">UportSubprovider</a>
<ul>
<li><a href="#new_UportSubprovider_new">new UportSubprovider(args)</a></li>
<li><a href="#UportSubprovider+send">.send()</a></li>
<li><a href="#UportSubprovider+sendAsync">.sendAsync(payload, callback)</a></li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_UportSubprovider_new"></a></p>
<h3>new UportSubprovider(args)</h3>
<p>Instantiates a new wrapped provider</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>args</td><td>Object</td><td><p>required arguments</p>
</td>
    </tr><tr>
    <td>args.requestAddress</td><td>function</td><td><p>function to get the address of a uPort identity.</p>
</td>
    </tr><tr>
    <td>args.sendTransaction</td><td>function</td><td><p>function to handle passing transaction information to a uPort application</p>
</td>
    </tr><tr>
    <td>args.provider</td><td>Object</td><td><p>a web3 sytle provider</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="UportSubprovider+send"></a></p>
<h3>uportSubprovider.send()</h3>
<p>Synchronous functionality not supported</p>
<p><strong>Kind</strong>: instance method of <a href="#UportSubprovider">UportSubprovider</a></p>
<hr>
<p><a name="UportSubprovider+sendAsync"></a></p>
<h3>uportSubprovider.sendAsync(payload, callback)</h3>
<p>Overrides sendAsync to caputure the following RPC calls eth_coinbase, eth_accounts,
and eth_sendTransaction. All other calls are passed to the based provider.
eth_coinbase, eth_accounts will get a uPort identity address with getAddress.
While eth_sendTransaction with send transactions to a uPort app with sendTransaction</p>
<p><strong>Kind</strong>: instance method of <a href="#UportSubprovider">UportSubprovider</a></p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>payload</td><td>Any</td><td><p>request payload</p>
</td>
    </tr><tr>
    <td>callback</td><td>function</td><td><p>called with response or error</p>
</td>
    </tr>  </tbody>
</table>
<hr>
</div></div></div><div class="tools"><div class="pagewrap"><div class="sidebar"></div><div class="content"><ul><li><a href="http://truffleframework.com" target="_blank"><img src="/img/truffle-logo.svg"><h3 class="title">Truffle</h3><p class="desc">Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.</p></a></li><li><a href="http://metamask.io" target="_blank"><img src="/img/metamask-logo.png"><h3 class="title">Metamask</h3><p class="desc">MetaMask is a bridge that allows you to visit the distributed web of tomorrow in your browser today. It allows you to run Ethereum dApps right in your browser without running a full Ethereum node.</p></a></li><li><a href="https://remix.ethereum.org/#version=soljson-v0.4.13+commit.fb4cb1a.js" target="_blank"><img src="/img/ethereum-logo.png"><h3 class="title">Remix</h3><p class="desc">Remix is an IDE for the smart contract programming language Solidity and has an integrated debugger and testing environment.</p></a></li><li><a href="https://github.com/ethereum/mist/releases" target="_blank"><img src="/img/mist-logo.png"><h3 class="title">Mist</h3><p class="desc">The Mist browser is a gateway to decentralized applications on the Ethereum blockchain. It allows you to hold and secure ether and other crypto-assets built on Ethereum, as well as write, deploy and use smart contracts.</p></a></li></ul></div></div></div><div class="myapps"><div class="pagewrap"><div class="sidebar"><section><h2>My Apps</h2><ul><li><a href="#"><span>Application 1</span></a></li><li><a href="#"><span>Application 2</span></a></li><li><a href="#"><span>Application 3</span></a></li><li><a href="#"><span>Application 4</span></a></li><li><a href="#"><span>Application 5</span></a></li></ul></section></div></div></div><div class="gitter"><div class="pagewrap"><div class="sidebar"></div><div class="content"></div></div></div></main><footer class="footer"><div class="footer-wrap"><div class="footer-left"><a class="logo-link" href="#"><div class="logo-group"><img class="logo-img" src="#"><span>| Uport.me</span></div></a></div><div class="footer-right"><nav class="nav"><ul class="nav-list"><li class="nav-item"><a class="nav-link" href="https://github.com/uport-project" target="_blank"><span>D.I.F.</span></a></li><li class="nav-item"><a class="nav-link" href="#" target="_blank"><span>Github</span></a></li></ul></nav><div class="legal-area"><a class="tos" href="#"><span>Terms of Service</span></a><a class="privacy" href="#"><span>Privacy Policy</span></a></div></div></div></footer><script>  ((window.gitter = {}).chat = {}).options = {
    room: 'uport-project/Lobby',
    activationElement: false,
    showChatByDefault: true,
    useStyles: false,
    preload: true,
    targetElement: '.gitter .content'
  };

/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script type="text/javascript" src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><script type="text/javascript" src="js/script.js"></script></body></html>
